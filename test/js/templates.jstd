TestCase("TemplateTests", {
    templates: travi.templates,

    templateName: 'someName',
    templateAsString: 'template',

    setUp: function () {
        travi.templates.init();
    },

    tearDown: function () {
        travi.test.common.restore(jQuery.ajax);
        travi.test.common.restore(jQuery.Deferred);
        travi.test.common.restore(jQuery.templates);
        travi.test.common.restore(jQuery.render[this.templateName]);
        travi.test.common.restore(this.templates.get);
        travi.test.common.restore(this.templates.preLoad);
    },

    "test preloading template requests it from the server, caches it, and returns the promise": function () {
        var pathToTemplate = '/path/to/template',
            call,
            promise,
            promiseToReturn = {},
            constructedDeferred = {
                promise: function () {
                    return promiseToReturn;
                },
                resolve: function () {}
            },
            testCase = this;

        sinon.stub(jQuery, 'ajax', function (options) {
            options.success.call(null, testCase.templateAsString);
        });
        sinon.stub(jQuery, 'Deferred').returns(constructedDeferred);
        sinon.spy(constructedDeferred, 'resolve');

        sinon.spy(jQuery, 'templates');

        promise = travi.templates.preLoad(this.templateName, pathToTemplate);

        assert(jQuery.ajax.calledOnce);
        call = jQuery.ajax.getCall(0);
        assertEquals(pathToTemplate, call.args[0].url);
        assertEquals("GET".toLowerCase(), call.args[0].type);
        assertEquals("text", call.args[0].dataType);

        this.assertPromiseResolvedAfterCachingTemplate(constructedDeferred);
        this.assertTemplateWasCached(this.templateName, this.templateAsString);
        this.assertPromiseWasReturned(promiseToReturn, promise);
    },

    "test the ability to get a template by name is exposed as a method": function () {
        assertFunction(travi.templates.get);
    },

    "test that getting a template by name requests it from the server and returns the promise": function () {
        sinon.stub(jQuery, 'ajax', function (options) {
            options.success.call(null, this.templateAsString);
        });

        var promise = travi.templates.get(this.templateName);

        assertEquals(
            '/templates/' + this.templateName + '.tmpl',
            jQuery.ajax.getCall(0).args[0].url
        );

        assertObject(promise);
        assertFunction(promise.promise);
    },

    "test template is rendered and returned as string": function () {
        var renderedTemplate,
            dataForTemplate = {
                data: 'something'
            };

        sinon.stub(jQuery.render, this.templateName).returns('renderedTemplate');

        renderedTemplate = travi.templates.render(this.templateName, dataForTemplate);

        this.assertTemplateRenderedWithData(dataForTemplate);

        assertString(renderedTemplate);
    },

    'test callback called after template loaded from server': function () {
        sinon.stub(jQuery, 'ajax');
        var constructedDeferred = new $.Deferred(),
            dataForTemplate = {
                data: 'something'
            },
            callback = sinon.spy(),
            renderedTemplate = 'renderedTemplate';
        constructedDeferred.resolve();
        sinon.stub(jQuery, 'Deferred').returns(constructedDeferred);
        sinon.stub(jQuery.render, this.templateName).returns(renderedTemplate);

        travi.templates.render(this.templateName, dataForTemplate, callback);

        sinon.assert.calledOnce(callback);
        sinon.assert.calledWith(callback, renderedTemplate);
    },

    'test callback not called when template not loaded': function () {
        sinon.stub(jQuery, 'ajax');
        var constructedDeferred = new $.Deferred(),
            dataForTemplate = {
                data: 'something'
            },
            callback = sinon.spy(),
            renderedTemplate = 'renderedTemplate';
        sinon.stub(jQuery, 'Deferred').returns(constructedDeferred);
        sinon.stub(jQuery.render, this.templateName);

        travi.templates.render(this.templateName, dataForTemplate, callback);

        sinon.assert.notCalled($.render[this.templateName]);
        sinon.assert.notCalled(callback);
    },

    "test that template is not requested from server if already cached": function () {
        sinon.stub(jQuery, 'ajax', function (options) {
            options.success.call(null, this.templateAsString);
        });

        travi.templates.get(this.templateName);
        travi.templates.get(this.templateName);

        sinon.assert.calledOnce(jQuery.ajax);
    },

    "test that caching does not prevent other templates from loading from server": function () {
        sinon.stub(jQuery, 'ajax', function (options) {
            options.success.call(null, this.templateAsString);
        });

        travi.templates.get(this.templateName);
        travi.templates.get('someOtherTemplateName');

        sinon.assert.calledTwice(jQuery.ajax);
    },

    'test template can be rendered without data': function () {
        this.templates.render(this.templateName);
    },

    assertTemplateRenderedWithData: function (data) {
        assert(jQuery.render[this.templateName].calledOnce);
        assertSame(data, jQuery.render[this.templateName].getCall(0).args[0]);
    },

    assertPromiseResolvedAfterCachingTemplate: function (deferred) {
        assert(deferred.resolve.calledOnce);
    },

    assertTemplateWasCached: function (templateName, templateAsString) {
        assert(jQuery.templates.calledOnce);
        assertEquals(templateName, jQuery.templates.getCall(0).args[0]);
        assertEquals(templateAsString, jQuery.templates.getCall(0).args[1]);
    },

    assertPromiseWasReturned: function (returnedPromise, promise) {
        assertObject(promise);
        assertSame(returnedPromise, promise);
    }
});